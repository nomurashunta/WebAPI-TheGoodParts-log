<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [6章](#6章)
  - [6.1 Web APIを安全にする](#61-web-apiを安全にする)
    - [6.1.1 どんなセキュリティの問題があるのか](#611-どんなセキュリティの問題があるのか)
  - [6.2 サーバとクライアントの間での情報の不正入手](#62-サーバとクライアントの間での情報の不正入手)
    - [6.2.1 HTTPSによるHTTP通信の暗号化](#621-httpsによるhttp通信の暗号化)
    - [6.2.2 HTTPSを使えば100%安全か](#622-httpsを使えば100安全か)
    - [補足: 認証局が攻撃を受けて偽の証明書を発光してしまうケース](#補足-認証局が攻撃を受けて偽の証明書を発光してしまうケース)
  - [6.3 ブラウザでアクセスするAPIにおける問題](#63-ブラウザでアクセスするapiにおける問題)
    - [6.3.1 XSS](#631-xss)
    - [6.3.2 XSRF](#632-xsrf)
    - [6.3.3 JSONハイジャック](#633-jsonハイジャック)
  - [6.4 悪意あるアクセスへの対策を考える](#64-悪意あるアクセスへの対策を考える)
    - [6.4.1 パラメータの改ざん](#641-パラメータの改ざん)
    - [6.4.2 リクエストの再送信](#642-リクエストの再送信)
      - [6.4.2.1 支払いの偽装](#6421-支払いの偽装)
  - [6.5 セキュリティ関係のHTTPヘッダ](#65-セキュリティ関係のhttpヘッダ)
    - [6.5.1 X-Content-Type-Options](#651-x-content-type-options)
    - [6.5.2 X-XSS-Protection](#652-x-xss-protection)
    - [6.5.3 X-Frame-Options](#653-x-frame-options)
    - [6.5.4 Content-Security-Policy](#654-content-security-policy)
    - [6.5.5 Strict-Transport-Security](#655-strict-transport-security)
    - [6.5.6 Public-Key-Pins](#656-public-key-pins)
    - [6.5.7 Set-Cookieヘッダとセキュリティ](#657-set-cookieヘッダとセキュリティ)
    - [補足：実際のAPIの対応状況を見てみる](#補足実際のapiの対応状況を見てみる)
  - [6.6 大量アクセスへの対策](#66-大量アクセスへの対策)
    - [6.6.1 ユーザーごとのアクセスを制限する](#661-ユーザーごとのアクセスを制限する)
    - [6.6.2 レートリミットの単位](#662-レートリミットの単位)
    - [補足：アクセス制限の緩和](#補足アクセス制限の緩和)
    - [6.6.3 制限値を超えてしまった場合の対応](#663-制限値を超えてしまった場合の対応)
      - [6.6.3.1 429以外のステータスコードが使われている例](#6631-429以外のステータスコードが使われている例)
    - [6.6.4 レートリミットをユーザーに伝える](#664-レートリミットをユーザーに伝える)
      - [6.6.4.1 HTTPのレスポンスでレートリミットを渡す](#6641-httpのレスポンスでレートリミットを渡す)
    - [補足：レートリミットの実装](#補足レートリミットの実装)
  - [6.7 まとめ](#67-まとめ)

<!-- /code_chunk_output -->

# 6章
## 6.1 Web APIを安全にする
- SnapShotやKickstarterなどのAPIがかつてAPIの問題により個人情報が漏洩した。一度失った信用を取り戻す事は難しいのでAPIのセキュリティには十分気を付ける必要がある
- 本章では特にAPIのセキュリティ面に注目し、APIについて最低限やっておくべき対策について見ていく事にする

### 6.1.1 どんなセキュリティの問題があるのか
- ここでは以下のようなパターンに分けて見ていくことにする
  - サーバーとクライアントの間での情報の不正入手
  - サーバーの脆弱性による情報の不正入手や改ざん
  - ブラウザからのアクセスを想定しているAPIにおける問題

## 6.2 サーバとクライアントの間での情報の不正入手
- HTTPというプロトコルそれ自体には、暗号化の仕様がない。例えば同じWifiにつないでいる人の通信を盗み見ることは非常に簡単である。APIの内容も対策を行わなければ、同じネットワーク上にいる他の人達に丸見えで、パスワードなどの個人情報を入れてしまっている場合非常に危険
- 直接そういった情報がなくとも、セッションIDなどでユーザーが特定され、盗まれたセッション情報から第三者のアクセスが可能になる場合がある(セッションハイジャック)。FireSheepというFireFoxのプラグインが以前話題になったが、これは同じWifiを使っている人が利用しているFacebookなどのサービスとのやりとりをキャプチャしてセッション情報を盗み、その人のIDでサイトにアクセスできるという、セッションハイジャックの仕組みを誰でも使えるようにしたものである

### 6.2.1 HTTPSによるHTTP通信の暗号化
- 最も簡単で効果のある方法は、HTTPによる通信を暗号化することで、最も広く使われ簡単に導入できるのはHTTPS(HTTP Secure)という、TLSによる暗号化である。HTTPSではURIのパス、クエリ文字列、ヘッダとボディ(リクエスト、レスポンス両方)で、やりとりに使われるほぼ全ての情報が暗号化される。FireFoxやTwitter,Googleなどの各サービスは残面的にHTTPSへ移行しており、APIの場合もエンドポイントが全てHTTPSになっているケースも数多くある

(参考：カゴヤ・ジャパン【図解】SSL/TLSとは何か？仕組みや導入方法をわかりやすく解説します https://www.kagoya.jp/howto/rentalserver/ssl/)

### 6.2.2 HTTPSを使えば100%安全か
- HTTPSが正しく使われていれば通信の盗聴やセッションハイジャックは不可能になるが、HTTPSを使っていれば100%安全というわけではない。2014年には、OpenSSLというHTTPSを実現するのによく使われているオープンソースの暗号化ライブラリに入ってたコードのバグが原因で、HTTPSで暗号化された情報を盗み取られる可能性が発覚した(Heartbleed)。100%の堅牢性を保つのは難しいので、常に新しい情報を取り入れて対応を行う必要がある
- サーバーが送ってきたSSLサーバー証明書が不正でないことを確かめない場合、**中間者攻撃(MITM:man-in-the-middle attack)**による盗聴などが行われる可能性がある。MITMはクライアントとサーバーの通信経路の間に入り込んで中継を行うことで情報を盗み出す手法で、証明書をきちんと検証することで、これを防ぐことができる
- 基本的にはHTTPS化することはかなり有効な手段だが、証明書を購入するのにコストがかかったり、アクセス速度が遅くなる問題はある。誰が行っても同じ結果が返る検索結果や、特に隠す情報がないAPIへのアクセスはHTTPを利用するなど、APIによって切り分ける方法も有効な方法である

### 補足: 認証局が攻撃を受けて偽の証明書を発光してしまうケース
- HTTPSによる対策が破られる可能性として、証明書を発行している認証局が攻撃を受け、攻撃者が不正に証明書を発行してしまうケースがある。対策として、あらかじめ本物の証明書の発行元や公開鍵データのフィンガープリントをブラウザに埋め込んで置いたり、レスポンスヘッダを使って渡しておき、実際の証明書のデータと比較して違いがないか確認したりする仕組みである、Certificate and Public Key Pinningという仕組みがある
(参考: MDN - HTTP Public Key Pinning (HPKP) https://developer.mozilla.org/ja/docs/Web/Security/Public_Key_Pinning)

## 6.3 ブラウザでアクセスするAPIにおける問題
- Web APIはHTTPという標準的な仕様の上に構築されるため、最も広く普及したHTTPクライアントであるウェブブラウザを経由した不正なアクセスや攻撃に対して注意を払う必要がある。ここではこれまで見つかってきたブラウザを用いた攻撃方法とそれに対する対策について見ていくことにする

### 6.3.1 XSS
- XSSはウェブアプリケーションの脆弱性としてよく知られているもので、ページのHTMLを埋め込んで表示する際に、ユーザーから受け取られたJavaScriptなどを実行できてしまうというもの。APIとしてJSONのようなデータを返す場合でも、同様の問題に注意する必要がある。例えば`Content-Type`の値が`text/html`だった場合など(注：4.4.5 メディアタイプとセキュリティの節を参照)
- ただし`Content-Type`を指定しただけではXSSへの対策としては不十分で、例えばInternet Explorerには`Content-type`を無視し、データの内容からデータ形式を推定する"Conten Sniffering"という機能があり、これによりJSONがHTMLと解釈されてしまう。これを防ぐには、IE8以降で実装された`X-Content-Type-Options`というレスポンスヘッダに`nosniff`を設定する必要がある
    ```
    X-Content-Type-Options: nosniff
    ```

### 6.3.2 XSRF 
- XSS(クロスサイトリクエストフォージェリ: Cross Site Request Forgery)は、サイトをまたいで偽装したリクエストを送りつけることで、ユーザーに意図しない処理をサーバーに実行させてしまうことを言う。例として、掲示板に勝手に投稿が行われたり、ECサイトで特定の商品の評価を不当に上げたりすることが考えられ、犯罪予告を勝手に書き込ませて誤認逮捕されるなどの事件が実際に発生している
- XSRFを避ける方法で一般的なのは、XSRFトークンを利用する方法で、これは送信元となる正規のフォームにワンタイムトークンなどを埋め込んでおき、トークンがないアクセスは拒否するというもの

### 6.3.3 JSONハイジャック
- JSONハイジャックとは、APIからJSONで送られてくる情報を悪意ある第三者が盗み取ることを言う。たとえば`script`要素には同一生成元ポリシーが適用されないため、これとさまざまな手法を使ってデータの読み込みを可能にするのがJSONハイジャックである

## 6.4 悪意あるアクセスへの対策を考える
- ここまでは第三者による情報の不正入手やユーザー、サービス両方に対する攻撃について考えてきたが、ここからはユーザー自身が不正を行おうとするケースについて考える

### 6.4.1 パラメータの改ざん
- 例えばuriにユーザーIDを埋め込む場合などでは、パラメータを変更することで他人の情報がわかるので、情報漏洩の可能性がないか検証しておく
- ゲームで用いられるAPIでパラメータを偽装するなど。クライアントから送られてきた情報を信頼せず、サーバー側で整合性をチェックすること

### 6.4.2 リクエストの再送信
- 一度送ったリクエストを再度送信することで、同じ処理をサーバー側にもう一度させることを言う。これを許すと例えばゲームで報酬を複数回もらえてしまう等の場合がある

#### 6.4.2.1 支払いの偽装
- アプリ内課金には消耗型、非消耗型の2種類があり、前者はポイントやアイテムの使ったらなくなるもの、後者は機能のアンロックなど購入後は機能が持続するもの。支払いの偽装は前者で特に問題となる
- 例えばポイント購入のリクエストを偽装されてしまうと、同じリクエストで複数回ポイント購入がなされるなどの危険性がある。これを防ぐには一度の購入で一回のポイント付与を行うようにチェックする必要があり、iOSやAndroidなどのアプリ内課金では購入完了後に発行されるコードをサーバー側で保存し過去に使われていないかのチェックが行われている

## 6.5 セキュリティ関係のHTTPヘッダ
- 以下に示すのはRFCで公式に定義されているものではないが、ブラウザが独自に実装したものが有効性から広く広がったもの

### 6.5.1 X-Content-Type-Options
- これを指定すると、IEのContent Sniffingを無視することができる。JSONでAPIを配信する場合は必ず付けておくべきである(注：6.3.1 XSS節参照)

### 6.5.2 X-XSS-Protection
- ブラウザが備えているXSSの検出、防御機能を有効にするヘッダ。IE8以上、Chrome、Safariで有効。つけていれば全てのXSSパターンを検出できるわけではないので気を付ける

### 6.5.3 X-Frame-Options
- 指定したページがフレーム(FRAMEとIFRAME要素)内で読み込まれるかどうかを制御することができるヘッダで、例えば以下のようにすると、そのデータがフレーム内で読み込まれることを防ぐことができる
    ```
    X-Framen-Options: deny
    ```
- これは**クリックジャッキング**と呼ばれる、透明化したIFRAMEを他のページで読み込み、意図しない動作を行わせる行為を防ぐために用いる

### 6.5.4 Content-Security-Policy
- 読み込んだHTML内のIMG要素、SCRIPT要素、LINK要素などの読み込み先としてどこを許可するのかを指定するためのヘッダで、画像の読み込みを自分自身と同じ生成元に限定することで、XSSの危険性を減らすなどができる

### 6.5.5 Strict-Transport-Security
- HTTP Strict Transport Security(HSTS)を実現するためのヘッダで、これを利用するとあるサイトへのブラウザからのアクセスをHTTPSのみに限定させることができる
    ```
    Strict-Transport-Security: max-age=15768000
    ```
- HTTPSでのアクセス時にこのヘッダが送られると、ブラウザは`max-age`の期間中この情報を保持しておき、同じサイトへのアクセス時は必ずHTTPSを使うようになる
- HTTPSへのアクセスが行われる前に一度HTTPでアクセスすると効果がなくなるが、例えば一度自宅でアクセスした際にHTTPSでのアクセスを記録しておけば、公共Wifiを使った際にHTTPが使われる可能性が低くなったりする

### 6.5.6 Public-Key-Pins
- HTTP-based public key pinning(HPKP)のためのヘッダで、SSL証明書が偽造されてないかのチェックに利用する(注：6.2.2節参照)。

### 6.5.7 Set-Cookieヘッダとセキュリティ
- Cookieのセキュリティのために使うヘッダで、例えば以下のように設定する
    ```
    Set-Cookie: session=~~~~~~; path=/; secure; HttpOnly
    ```
- `Secure`属性を付けると、そのクッキーはHTTPSの通信時にのみサーバーに送り返され、`HttpOnly`属性を付けると、そのクッキーがHTTPの通信のみで行われ、ブラウザでjsなどのスクリプトを使ってアクセスできないことを示す

### 補足：実際のAPIの対応状況を見てみる
- foursquareのAPIのレスポンスヘッダには、`X-XSS-Protection`、`X-Frame-Options`などの上記で説明したヘッダが多く指定されている。実際に公開されているAPIでもこうしたセキュリティ強化のためのヘッダが多く使われていることがわかる

## 6.6 大量アクセスへの対策
- 大量のアクセスを受けると、サーバーは負荷に耐えられなくなりアクセスができなくなる。これを利用したのがDoS攻撃で、このような大量アクセスは攻撃ではなく開発者の不注意で行われてしまうこともあるため、Web APIでは備える必要がある。

### 6.6.1 ユーザーごとのアクセスを制限する
- 上記の問題は、ユーザーごとにアクセス数を制限することが現実的な解決法となる。このようなレートリミットを行うにあたっては、以下のようなことを決める必要がある
  - 何を使ってユーザーを識別するか
  - リミット値をいくつにするか
  - どういう単位でリミット値を設定するか
  - リミットのリセットをどのタイミングで行うか

### 6.6.2 レートリミットの単位
- 種々のAPIの例を見ると、レートリミットの制限値は想定されるユースケースによって調整が加えられている。例えば参照系のAPIは制限がゆるいなど
- レートリミットの単位時間に関しては、時間単位を1日に設定しているAPIもあるが、一度間違えて制限に引っかかってしまうと解除に24時間かかるので、これでは長すぎる場合がある。一般的には15分~1時間程度に設定しているものが多い

### 補足：アクセス制限の緩和
- 優良顧客となるような特定のアプリや開発者に対して規制を緩和することが考えられ、制限値以上のアクセスが必要なら開発者に連絡すれば解除が検討されるAPIもある。無料枠を超える場合はお金を払うというシステムも一般的

### 6.6.3 制限値を超えてしまった場合の対応
- 制限値を超えた場合に返すべきステータスコードは"429 Too Many Requests"。RFCの仲ではこのステータスコードについて以下のように書かれている
  - エラーの詳細をレスポンスに含めるべきである(Should)
  - Retry-Afterヘッダを使って次のリクエストをするまでにどれくらい待てばよいかを指定しても良い(May)
- ユーザーの特定方法およびリクエストの数え方については定義されていないので、これはどのような制限をどのような単位で行ったとしてもステータスコード429が利用できることを意味している

#### 6.6.3.1 429以外のステータスコードが使われている例
- 実際には429以外のステータスコードが使われていることが多い。429が定義されたのは2012年と比較的新しいことが原因と考えられるが、今後APIを設計するなら429を使うべきである
    | サービス名 | ステータスコード |
    | ---- | ---- |
    | Twitter | 429 |
    | Github | 403 |
    | Instagram | 503 |
    | Heroku | 429 |
    | Pocket | 403 |
    | HipChat | 403 |

### 6.6.4 レートリミットをユーザーに伝える
- レートリミットを利用者が取得可能にしておくと、自律的にアクセス量を調整するクライアントを書くことができる。レートリミットを利用者に知らせる方法はいくつかあり、最も簡単なのはドキュメントに書くことだが、より優れた方法として、APIの利用者向けダッシュボードの中で利用回数や制限を表示するというものがあり、例えばGoogleのAPI Consoleがこれを行っている

#### 6.6.4.1 HTTPのレスポンスでレートリミットを渡す
- 毎回のAPIアクセスの際に、APIの残りアクセス可能回数などをレスポンスに含めて返す方法がある。現在デファクトスタンダードになっているのは、以下のようなヘッダ名で値を格納する方法で、GitHubやTwitterなどが実装している

    | ヘッダ名 | 説明 |
    | ---- | ---- |
    | `X-RateLimit-Limit` | 単位時間あたりのアクセス上限 |
    | `X-RateLimit-Remaining` | アクセスできる残り回数 |
    | `X-RateLimit-Reset` | アクセス数がリセットされるタイミング |

### 補足：レートリミットの実装
- APIのレートリミットを実装するには、ユーザーやアプリケーション毎にアクセス回数をカウントしておく必要がある。RedisなどのKey-Value型DBを使うか、Apigeeなどの何らかのサービスを利用する必要がある

## 6.7 まとめ
- [Good] 個人情報など特定のユーザー以外に漏洩したくない情報がある場合はHTTPSを使う
- [Good] XSS、XSRFなど通常のウェブと同様のセキュリティだけでなくJSONハイジャックなどAPI特有の脆弱性に気を配る
- [Good] セキュリティ強化につながるHTTPヘッダをきちんと付ける
- [Good] レートリミットを設けることで一部のユーザーによる過度のアクセスによる負荷を防ぐ