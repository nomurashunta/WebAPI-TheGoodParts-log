
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [3章 レスポンスデータの設計](#3章-レスポンスデータの設計)
  - [3.1 データフォーマット](#31-データフォーマット)
    - [3.1.1 データフォーマットの指定方法](#311-データフォーマットの指定方法)
  - [3.2 JSONPの取り扱い](#32-jsonpの取り扱い)
    - [3.2.1 JSONPをサポートする場合の作法](#321-jsonpをサポートする場合の作法)
    - [3.2.2 JSONPとエラー処理](#322-jsonpとエラー処理)
    - [補足:JSONPをサポートするべきか？](#補足jsonpをサポートするべきか)
  - [3.3 データの内部構造の考え方](#33-データの内部構造の考え方)
    - [3.3.1 レスポンスの内容をユーザーが選べるようにする](#331-レスポンスの内容をユーザーが選べるようにする)
    - [3.3.2 エンベロープは必要か](#332-エンベロープは必要か)
    - [3.3.3 データはフラットにすべきか](#333-データはフラットにすべきか)
    - [3.3.4 配列とフォーマット](#334-配列とフォーマット)
    - [3.3.5 配列の件数、あるいは続きがあるかをどう返すべきか](#335-配列の件数-あるいは続きがあるかをどう返すべきか)
  - [3.4 各データのふぉーまっと](#34-各データのふぉーまっと)
    - [3.4.1 各データの名前](#341-各データの名前)
    - [3.4.2 性別のデータをどう表すか](#342-性別のデータをどう表すか)
    - [3.4.3 日付のフォーマット](#343-日付のフォーマット)
    - [3.4.4 大きな整数とJSON](#344-大きな整数とjson)
  - [3.5 レスポンスデータの設計](#35-レスポンスデータの設計)
  - [3.6 エラーの表現](#36-エラーの表現)
    - [3.6.1 ステータスコードでエラーを表現する](#361-ステータスコードでエラーを表現する)
    - [3.6.2 エラーの詳細をクライアントに返す](#362-エラーの詳細をクライアントに返す)
    - [3.6.3 エラー詳細情報には何を入れるべきか](#363-エラー詳細情報には何を入れるべきか)
    - [3.6.4 エラーの際にHTMLが返ることを防ぐ](#364-エラーの際にhtmlが返ることを防ぐ)
    - [3.6.5 メンテナンスとステータスコード](#365-メンテナンスとステータスコード)
    - [3.6.6 意図的に不正確な情報を返したい場合](#366-意図的に不正確な情報を返したい場合)
  - [3.7 まとめ](#37-まとめ)

<!-- /code_chunk_output -->

# 3章 レスポンスデータの設計
## 3.1 データフォーマット
- レスポンスデータのデータフォーマットは、基本的にJSONにデフォルトで対応し、需要や必要があればXMLに対応する

### 3.1.1 データフォーマットの指定方法
- データフォーマットの指定方法には、クエリパラメータを使う方法、拡張子を使う方法、リクエストヘッダでメディアタイプを指定する方法がある

## 3.2 JSONPの取り扱い
JSONP(JSON with padding)はJSONをブラウザに渡す方法の一つで、通常は以下のようにJSONにそれをラップするJavaScriptを加えたもの
```
callback({"id":123,"name":"Saedd"})
```
このJavaScriptをscript要素で読み込み、ページ側のcallback関数で処理をする
```
<script src="https://api.example.com/v1/users?callback=callback">
```
- JSONPがなぜ考案されたか？というと、XHTTPRequestの同一生成元ポリシーの制限を避けるため。XHTTPRequestは同じ生成元(ドメインなど)のアクセスしか行うことができないという同一生成ポリシーの制限を受けるが、script要素はこの規制の対象外なため、JSONをscript要素を使ってJavascriptで読み込むことで、ドメインを超えたアクセスが可能になる

### 3.2.1 JSONPをサポートする場合の作法
- コールバック関数の名前はクエリパラメータで指定できるようにするのが一般的。例えば以下では`cbfunc`という関数名を指定している
  ```
  <script src="https://api.example.com/v1/users?callback=cbfunc">
  ```
-  このようにするとよい理由は2つある
   1. コールバック関数名を決め打ちすると、その名前がページ内の他の関数と衝突してしまう可能性があるため
   2. 同じAPIを複数回アクセスする場合、それぞれを異なるコールバック関数にすることで、返されたデータがどのリクエストによって得られたものなのかを区別できるようにするため
- フォーマットとしてJSONPを返すための指定方法は、単にクエリパラメータにコールバック関数の指定があればJSONPを要求しているとみなす、とするのが一般的
- 注意点として、`Content-Type`ヘッダに設定するメディアタイプを`application/json`ではなく`application/javascript`にすること。設定しなくても動くがセキュリティなどの穴がある可能性がある

### 3.2.2 JSONPとエラー処理
- JSONPの問題として、script要素は400などエラーのステータスコードが返るとスクリプトの読み込みをやめてしまうため、サーバーがエラーを起こした場合に正しく対応できないというものがある
- JSONPではエラーが発生しても200のステータスコードを返し、レスポンスボディでエラーの内容を表現することで対応する。つまり以下のように、本来ヘッダに入るべきステータスコードなどの情報をボディに格納する
  ```
  {
    status_code: 404,
    error_message: "User Not Found"
  }
  ```

### 補足:JSONPをサポートするべきか？
- 対応する必要があるわけでなく、対応する必要がなければしないほうがいい。セキュリテイ上の理由などがある。詳しくは6章で

## 3.3 データの内部構造の考え方
- レスポンスデータを決定する際にまず考えるべきことは、APIのアクセス回数がなるべく減るようにすること

### 3.3.1 レスポンスの内容をユーザーが選べるようにする
- 例えばユーザー情報のうち名前と年齢を取得することを指定するには
  ```
  https://api.linkedin.com/v1/users?fields=name,age
  ```
- 他にも**レスポンスグループ**を利用するなど

### 3.3.2 エンベロープは必要か
- エンベロープとは以下のような型式を指す
  ```
  {
    "header":{
      "status": "success",
      "errorcode": 0,
      },
    "response": {
      ... -実際のデータ- ...
    }
  }
  ```
- 一見便利なようだが、実際には冗長なのでやるべきではない。Web APIは基本的にHTTPを利用しており、HTTPは実質的にエンベロープの役割を果たしているため。ヘッダの概念もあり、ステータスコードをきちんと返すことでエラーの判断もできる。
- 例外的に、JSONPを利用する場合であれば、エンベロープ的なものを利用したほうが便利
  
### 3.3.3 データはフラットにすべきか
- 「フラットにする」とは、JSONやXMLの階層構造を使わないこと
- 階層構造とフラットに表す場合でどちらがよいか。GoogleのJSON Style Guideでは「なるべくフラットにしたほうがよいが、階層構造を持ったほうがわかりやすい場合もある」となっている

### 3.3.4 配列とフォーマット
- SNSの友人一覧やタイムラインなど、APIで配列を返したい場合、配列をそのまま返すか、またはレスポンス全体をオブジェクトにしてその中に配列を入れるか
  - 筆者の意見としては、オブジェクトで包んだ記述方法の方がおすすめ
    - レスポンスデータが何を示しているかわかりやすくなる。例えば`friends`が友人の情報であることがわかりやすいなど
    - レスポンスデータをオブジェクトに統一することができる。トップレベルが配列だったりオブジェクトで異なると、クライアントで取得した際に共通の前処理をすることが面倒になる場合がある
    - セキュリティ上のリスクを避けることができる。前二つよりこちらが重要。トップレベルが配列であるJSONは、JSONインジェクションという脆弱性に対するリスクが大きくなる

### 3.3.5 配列の件数、あるいは続きがあるかをどう返すべきか
- 検索結果や友達一覧などの配列を返すデータでは、2章で触れたような「絶対位置での指定」を行う設計にする場合がある
- ページングの SNSのタイムラインなどは全部の件数の情報は必要でない

## 3.4 各データのふぉーまっと
### 3.4.1 各データの名前
- データ項目の名前の付け方について考える。ユーザーIDなら`userId`など
- エンドポイントのデザインと重複する部分が多いが、以下に改めて列挙する
  - 多くのAPIで同じ意味に利用されている一般的な単語を用いる
  - なるべく少ない単語数で表現する
  - 複数の単語を連結する場合、その連結方法はAPI全体を通して統一する
  - 変な省略系は極力使用しない
  - 単数系/複数形に気をつける

### 3.4.2 性別のデータをどう表すか
- 性別情報をデータで表す方法には、主に"male"、"female"などの文字列で表す方法と、1なら男性、2なら女性など数値に置き換えて表す方法の2通りがある
- 一般的なAPIの例をみると、文字列で表すのが多数。また、フィールド名が`sex`のときは数値で、`gender`のときは文字列で表されることが多い。理由として、 `sex`は「生物学的な性別」を表し種類が少ないのに対し、`gender`は「社会的・文化的性別」を表し多様な値をとりうるから。フィールド名をどちらにするかで迷った時は、同じ基準で考えると良い
  - FaceBookなどは選択可能な性別が50種類以上もある。社会的に認められつつある性別の多様性に対応することを考えると、フィールド名を`gender`としたときは文字列で返すほうがよいといえる  

### 3.4.3 日付のフォーマット
- 日付の形式にはいくつかあるが、どれを使うのが適切か
- 結論としてRFC3339を使うのが良い。このフォーマットは数あるこれまでの日時フォーマットの問題点を解決し、読みやすく使いやすいものを目指してインターネット上で用いる標準形式として決められたものであるから
  - タイムゾーンは"+00:00"を使うのがよい 

### 3.4.4 大きな整数とJSON
- SQLの`int`など32ビット整数の場合、42億までしか表すことができない。それ以上の数はSQLでは`bigint`など64ビット整数を使う
  - 例えばTwitterでは、ツイートのIDやユーザーIDが符号付き32ビット領域を超えているという
- 大きな数字はシステムによってはトラブルを起こす可能性があるので注意する。例えば以下のコードをブラウザで実行したとする(数字はTwitterのツイートID)。
  ```
  var data = JSON.parse('{"id":462781738297483264\}');
  console.log(data.id)
  ```
  **この場合、実際に表示されるのは`462781738297483264`ではなく`462781738297483260`。** これはJavaScriptが数値をすべてIEEE754標準の64ビット不動少数として扱うため、大きな整数を扱うと誤差が出るから
- IDなど巨大な数を扱う場合、数値を文字列で表すとこのような問題を回避できる。例えばTwitterのAPIでは、IDは`id`のほかに`id_str`という同じ数値を文字列で格納したものを返すようになっている
  ```
  {
    "id": 462781738297483264,
    "id_str": "462781738297483264",
    ...
  }
  ```  

## 3.5 レスポンスデータの設計
- ユーザー情報などをデータ構造として定義すると、クライアント側では同じコードで処理をできるようになるため楽になる。例えばFacebppkのAds APIはドキュメントないに"Objects"という項目があり、そこに広告APIで利用されるオブジェクト構造がドキュメント化されている。APIで返される構造はなるべくわかりやすくシンプルに

## 3.6 エラーの表現
### 3.6.1 ステータスコードでエラーを表現する
- エラーを返す際にまず考えることは、適切なステータスコードを使うこと。ステータスコードの基本の分類は以下の通り
  |  ステータスコード  |  意味  | 
  | ---- | ---- | 
  | 100番台 | 情報 | 
  | 200番台 | 成功 | 
  | 300番台 | リダイレクト | 
  | 400番台 | クライアントサイドに起因するエラー | 
  | 500番台 | サーバーサイドに起因するエラー |

- 注意するべきは、クライアントのリクエストが成功した場合しか200番台のリクエストは返してはならないということ。データとしてはエラー情報が返るもののステータスコードは200を返すケースがあるが、これは使い方としては正しくなく、例えば汎用的なHTTPのクライアントライブラリにはステータスコードを見てリクエストの成功を判断しているものも多いため、クライアント側の手間も増える。

### 3.6.2 エラーの詳細をクライアントに返す
- ステータスコードだけでは情報が不十分なため、エラーの詳細な内容を返すことが重要になる。エラー内容を返す方法には、大きく分けてレスポンスヘッダに入れて返す方法、レスポンスボディで返す方法の2通りがある。
  - レスポンスヘッダに入れて返す方法の例
    ```
    X-MYNAME-ERROR-CODE: 2013
    X-MYNAME-ERROR-MESSAGE: Bad authentication token
    X-MYNAME-ERROR-INFO: https://docs.example.com/api/v1/authentication
    ```
  - レスポンスボディで返す方法の例
    ```
    {
      "error": {
        "code": 2013,
        "message": "Bad authentication token",
        "info": "https://docs.example.com/api/v1/authentication"
      }
    }
    ```
- ヘッダとボディどちらで返すべきか？現実に公開されているAPIでは、ほとんどボディにエラーメッセージを格納している。クライアント側から見たときの利便性を考えても、レスポンスボディにデータを入れる方法で問題ないといえる
- Twitterなどは複数エラーが同時に発生したときのため、エラーを配列で返している

### 3.6.3 エラー詳細情報には何を入れるべきか
- エラーの詳細コードはステータスコードと分けて4桁の数字にし、1000番代は汎用的なエラー、2000番台はユーザー情報のエラーなど、ステータスコードと同様のカテゴリ分けをすると便利かもしれない。エラーコードはAPI同様にオンライン上のドキュメントで公開する
- エラーメッセージに関しては、非開発者向けと開発者向けのメッセージ両方を含める方法もある

    ```
    {
      "error": {
        "developerMessage": "...開発者向けエラーメッセージ...",
        "userMessage": "...非開発者向けエラーメッセージ...",
        "code": 2013,
        "info": "https://docs.example.com/api/v1/authentication"
      }
    }
    ```

### 3.6.4 エラーの際にHTMLが返ることを防ぐ
- エラーの際にリクエストボディがHTMLになってしまうAPIが存在し、特に500,503,404などのエラーでよく見られ、例えば存在しないエンドポイントにアクセスしようとした時にウェブサーバーやアプリケーションフレームワークがエラーを返す場合がある。実際には頑強なAPIといえないので、APIの実装内部でエラーが発生したり存在しないエンドポイントにアクセスした場合でも適切なフォーマットでデータを返すようにする

### 3.6.5 メンテナンスとステータスコード
- 基本的にAPIの停止は避けるべきだが、どうしてもメンテナンスが必要な場合は、ステータスコード503を返し現在サービスが停止していることを伝える必要がある。定期メンテナンス用のエラーメッセージを返すだけでなく、HTTPヘッダに`Retry-After`を使いいつメンテナンスが終わるかを示すのがよい。これは「次にいつアクセスしてください」ということを表すためにHTTP1.1の仕様で正式に定義されたヘッダで、SEO的な観点では通常のウェブサイトのメンテナンスでも利用することをGoogleも推奨している
  ```
  503 Service Temporarily Unavailable
  Retry-After: Mon, Dec 2013 03:00:00 GMT
  ```

### 3.6.6 意図的に不正確な情報を返したい場合
- セキュリティやその他の理由から、あえて情報を曖昧にしたい場合が存在する。例えばSNSのブロック機能で、403を返すと相手からブロックされている事がわかってしまうため、「ブロックされた側から見るとブロックした側はもはや存在しないと同義」とみなして404を返すことも可能
- 他の例では、メールアドレスとパスワードでのログインに失敗したとき、ログイン失敗の原因などの情報を与えすぎると、不正ログインなど悪意を持ったユーザーに情報を与えることになるため、あえて多くの情報を返さないことが考えられる

## 3.7 まとめ
- [Good] JSON、あるいは目的に応じたデータ形式を採用する
- [Good] データを不要なエンベロープで包まない
- [Good] レスポンスを出来る限りフラットな構造にする
- [Good] 各データの名前が完結で理解しやすく、適切な単数複数が用いられている
- [Good] エラーの形式を統一し、クライアント側でエラー詳細を機械的に理解可能にする　
