# 4章 HTTPの仕様を最大限利用する
## 4.1 HTTPの仕様を利用する意義
- インターネット上で利用される仕様の多くはRFC(Request for Comments)と呼ばれる仕様書で定義されており、HTTPの最新バージョン1.1はRFC 7230から始まる文書群で定義されている(注:2020年現在の最新バージョンはHTTP/3)
- HTTPは一対のリクエストとレスポンスで構成されており、それぞれにヘッダとボディがある。レスポンスボディはサーバーから返ってくるデータ、リクエストボディはサーバーに送信するデータが入り、ヘッダはそれぞれに関するメタ情報を入れることができる
- HTTPのヘッダはすでにRFCで定義されているものも多くあり、デファクトスタンダードとなっているものもあるが、それ以外で独自に定義することも可能
  
## 4.2 ステータスコードを正しく使う
- ステータスコードはHTTPのレスポンスヘッダの先頭に必ず入っている3桁の数字。

| ステータスコード | 内容 | 説明 |
| ---- | ---- | ---- |
| 200 | OK | リクエストは成功した |
| 201 | Created | リクエストが成功し、新しいリソースが作られた |
| 202 | Accepted | リクエストが成功した |
| 204 | No Content | コンテンツなし |
| 300 | Multiple Choices | 複数のリソースが存在する |
| 301 | Moved Permanently | リソースは恒久的に移動した |
| 302 | Found | リクエストしたリソースは一時的に移動している |
| 303 | See Other | 他を参照 |
| 304 | Not Modified | 前回から更新されていない |
| 307 | Temporary Redirect | リクエストしたリソースは一時的に移動している |
| 400 | Bad Request | リクエストが正しくない |
| 401 | Unauthorized | 認証が必要 |
| 403 | Forbidden | アクセスが禁止されている |
| 404 | Not Found | 指定したリソースが見つからない |
| 405 | Method Not Allowed | 指定されたメソッドは使う事ができない |
| 406 | Not Acceptable | Accept関連のヘッダに受理できない内容が含まれている |
| 408 | Request Timeout | リクエストが時間以内に完了しなかった |
| 409 | Conflict | リソースが矛盾した |
| 410 | Gone | 指定したリソースは消滅した |
| 413 | Request Entity Too Large | リクエストボディが大きすぎる |
| 414 | RequestURI Too Long | リクエストされたURIが長すぎる |
| 415 | Unspported Media Type | サポートしていないメディアタイプが指定された |
| 429 | Too Many Requests | リクエスト回数が多すぎる |
| 500 | Internal Server Error | サーバ側でエラーが発生した |
| 503 | Service Unavailable | サーバーが一時的に停止している |

### 4.2.1 200番台 成功
- 201は"Created"で、リクエストの結果サーバ側でデータ作成が行われた場合。つまりリクエストメソッドとしてPOSTが使われた場合
- 202の"Accepted"は、リクエストした処理が非同期で行われ、処理を受け付けたが完了していない場合に利用されるもの。例えばファイル形式の変換や、リモートノーティフィケーションなどの時間のかかる処理を行う時、一度クライアントにレスポンスを返しサーバ側で非同期に処理を行うなどの際に利用する
  - 実際はもう少し幅の広い解釈のもと利用されている。例えばLinkedInのAPIで投稿時にモデレータの承認が必要な場合202が返ったり、またBoxのAPIではファイルのダウンロード時、ファイルがまだ準備できていない場合に202が、`Retry-After`ヘッダとともに返ったりする 
- 204は"No Content"の通り、レスポンスが空のときに返る。APIの利用例でよく見られるのは、DELETEメソッドなどでデータの削除を行った際に204を返すというもの
  - 一方で、204はあまり使うべきでないという人もいる。根拠としては以下の通り
    - レスポンスが空であるということは情報が少なすぎて解釈に困るから
    - PUTやPATCHでは変更された状態のデータを、DELETEでは削除されたデータそのものを返すべきだから
  - 筆者の意見としては、PUTやPATCHの場合は200とともに操作したデータを返し (POSTの場合は201)、DELETEの場合は204を使うのがよい
    - DELETEの場合は、不要なデータだから削除しているのであり、そのあとのデータを受け取る処理はあまり必要にならないと考えられる
    - そもそも削除の際に受け取るデータにクライアントが依存する場合、何らかの問題でサーバ側で削除は行われたが、データを受け取ることができなかった場合に復帰が難しくなるので、あまり有効ではない

### 4.2.2 300番台 追加で処理が必要
- 300番台のステータスコードで最もよく知られているのはリダイレクトで、リダイレクトに関するものは301,302,303,307の4つがある。リダイレクトの場合は`Location`というレスポンスヘッダにリダイレクト先の新しいURIが含まれる
- APIの場合もリダイレクトを利用することはありえるが、ウェブサイトのようにURIの変更、サイトの移転や一時的な移動に伴ってリダイレクトを行うことは好ましくない。またリダイレクトが発生するとアクセス回数も増えるので、定常的にリダイレクトが発生するようなAPIは作るべきではない
- リダイレクト以外の300番台のステータスコードには以下がある
  - 300は複数の選択肢がある場合に送信され、指定したURIが取得するデータを一意に特定するには曖昧で、複数の可能性がある場合
    - 基本的にこれを返す場合は極めて少ないが、ファイルストレージ系のサービスで指定したキーに対して複数のデータが存在すると返る場合がある。分散データベースであるRiakのAPIも、指定された文書のキーに対して複数のデータが存在すると300を返す
  - 304(Not Modified)は以前のデータ取得から更新されていないことを表すコードで、レスポンスボディは空になる。これが返るのはクライアント側できちんとデータのキャッシュを行い、キャッシュの情報を返してくれたときだけで、キャッシュが有効なら通信量が減り高速になる。

### 4.2.3 400番台 クライアントのリクエストに問題があった場合
- 400(Bad Request)は「その他」、他の400番台のエラーでは表す事ができないエラーに使うためのコードで、例えば送られてきたパラメータに間違いがあって処理が続行できないときなどに返す
- 401(Unauthorized)と403(Forbidden)は似ているが、401は認証(Authentication)、403は認可(Authorization)のエラーを表す。前者は「アクセスしてきたのが誰であるか識別すること」、後者は「特定のユーザーに対してある操作の権限を許可すること」
  - APIにトークンなしでアクセスした場合は401が返る。一方で管理者しかアクセスできないAPIに一般ユーザーの権限でアクセスした時は403が返る
- 404(Not Found)はアクセスしようとしたデータは存在しないという意味のエラー。何が存在しなかったかはきちんと何らかの方法で伝える必要がある
- 405 (Method Not Allowed)はエンドポイントは存在しているが、メソッドは許可されていない場合に利用する。検索用のAPIにPOSTでアクセスした場合など
- 406(Not Acceptable)はクライアントが指定してきたデータ形式にAPIが対応していない場合に返すエラー。JSONとXMLしか対応していないのにYAMLが指定された場合など
- 408(Request Timeout)はクライアントがサーバ側にリクエストを送るのに時間がかかりすぎて、サーバ側でタイムアウトを起こした際に発生する
- 409(Conflict)は、同じIDのデータが存在する場合など。例えばメールアドレスやFacebookのIDを使ってユーザー登録をする場合、409を返してすでに使用済みのアドレスやIDであることを表すなど
- 410(Gone)は、リソースがかつて存在したが削除などにより今は存在しないことを表す。この場合データを削除したという情報を保持する必要があり、しかもそれを保持していることが利用者からわかるため、例えばユーザー情報をメールアドレスで検索すAPIなどで利用する場合、個人情報保護などの観点から問題を指摘される可能性があるかもしれない
- 413(Request Entity Too Large)、414(RequestURI Too Long)はそれぞれリクエストボディ、リクエストヘッダが長すぎるときのエラー。前者はファイルアップロードAPIで許容サイズ以上のデータが送られたとき、後者はGET時のクエリパラメータで長すぎるデータが指定されたときなど
- 415(Unspported Media Type)はリクエストヘッダの`Content-Type`で指定されているデータ形式にサーバが対応していないケースに発生する。406がクライアントが受け取りたい形式にサーバが対応していないケースであるのに対し、415はPOSTやPUTで送ってきたリクエストボディのデータ形式にサーバが対応していない場合に返す
- 429(Too Many Requests)はアクセス回数が許容範囲の限界を超えた場合に変えるエラーで、このような制限をレートリミットと呼ぶ。レートリミットについては6章で後述する

### 4.2.4 500番台 サーバに問題があった場合
- 500(Internal Server Error)は、サーバ側のコードにバグがあって処理が停止してしまった場合などに発生する。
- 503(Service Unavailable)は、サーバが一時的に利用できない状態になっていることを示すもの。メンテナンスのためにサービスを止める時に意図的に返す場合や、サーバーが過負荷でレスポンスを返せない際にロードバランサなどウェブサーバの前段にいるサーバーが返す場合がある

## 4.3 キャッシュとHTTPの仕様
- ここでのキャッシュとは、サーバーへのアクセスの頻度や通信量を減らすためにクライアント側で一度取った情報を保持しておき、再度必要になったときにあらかじめ取得してあった情報を利用することを言う
- キャッシュのメリットには以下がある

### 4.3.1 Expiration Model(期限切れモデル)
- HTTPにはキャッシュの仕組みが用意されているので、APIでもこれを利用することができる。HTTPのキャッシュにはExpiration Model(期限切れモデル)、Validation Model(検証モデル)の2つのタイプがある
- 期限切れモデルはあらかじめレスポンスデータに保存期間を決めておき、期限が切れたら再度アクセスをして取得を行うもの。いつ期限が切れるかをレスポンスに含めて返す事で実現でき、HTTP1.1ではそのための方法がCache-Controlレスポンスヘッダを使う方法とExpiresレスポンスヘッダを使う方法の二通りある
  ```
  Expires: Fir, 01 Jan 2016 00:00:00 GMT
  Cache-Control: max-age=3600
  ```
- `Expires`は天気情報など、特定の日時に更新されることが予めわかっているデータに使い、`Cache-Control`は更新頻度は低くないもののあまり頻繁にアクセスしてほしくない場合に利用する
- 2つ同時に利用された時はより新しい仕様である`Cache-Control`が優先される
- `max-age`の計算には`Date`ヘッダが利用される。Dateヘッダはサーバーがレスポンスを生成した日時を表すヘッダで、いくつかの例外を除き必ず付ける必要がある

### 補足:HTTP時間の形式
- HTTPヘッダではRFC 3339形式がよいと述べたが、HTTPヘッダでは使えない。HTTPヘッダで使える日時はRFC1123(IMF-fixdate)、RFC850(rfc850-date)、asctime(asctime-date)の3種類のみ
- このうち使うべきはRFC1123で、残りの二つは後方互換のために残されているだけで使うべきではない
   
### 4.3.2 Validation Model(検証モデル)
- 検証モデルは今保持しているキャッシュが最新であるかを問い合わせて、データが更新されていた場合のみ取得を行うもの。大きなデータをやりとりするAPIであるほどキャッシュの効果が高まる
- 検証モデルを行うには、条件付きリクエストに対応する必要がある。条件付きリクエストでは、保持している情報が更新されていた場合に情報を要求するもので、更新されていた場合のみ2データを返し、されていない場合は304("Not Modified")を返すもの
- `Last-Modified`と`If-Modified-Since`ヘッダを利用するか、`ETag`と`If-None-Match`ヘッダを利用して実現する
### 4.3.3 Heuristic Expiration(発見的期限切れ)
- サーバー側が明示的な期限を与えなかった際にクライアントがデータをどのくらいの間保持すればよいか決めるための方針についても言及されており、これをHeuristic Expiration(発見的期限切れ)と呼ぶ。例えばクライアントが独自の判断でアクセス回数を減らすことを言う

### 4.3.4 キャッシュをさせたくない場合
- `Cache-Controle: no-cache`とすることで明示的にキャッシュをしてほしくないことを伝える事ができる。株価情報など情報の新鮮さが問われる情報を配信する場合などに利用する

### 4.3.5 Varyでキャッシュの単位を指定する
- `Vary`はキャッシュを行う際に、URI以外にどのリクエストヘッダ項目をデータを一意に特定するために利用するかを指定する。ウェブページで、スマートフォンからのアクセスの際には同じURIでもモバイル向けのコンテンツを表示するなどのケースで利用が推奨される
  (参考: Varyヘッダについての解説記事 https://webtan.impress.co.jp/e/2013/05/17/15269)

### 4.3.6 Cache-Controlヘッダ
- `Cache-Control`では`max-age`や`no-cache`以外にも、キャッシュをクライアントやプロキシがどのように行えばよいかの情報(ディレクティブ)を指定でき、これらは複数同時に指定できる
  ```
  Cache-Control: public, max-age=604800, immutable
  ```
  (参考: MDN Web docs-Cache-Control https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Cache-Control)

## 4.4 メディアタイプの指定
- メディアタイプ(またはMINEタイプ)はレスポンスやリクエストのデータ形式を表し、`Content-Type`ヘッダを利用して指定する。メディアタイプの記述は以下のようになる
  - タイプ名/サブタイプ名;引数=値
  - 引数は省略可能で、例えばテキストの場合は`text/plain;charset=UTF-8`のようになる
- (参考: MDN Web docs - MIME タイプ https://developer.mozilla.org/ja/docs/Web/HTTP/Basics_of_HTTP/MIME_types)
- (参考: Qiita - Content-Typeの一覧 https://qiita.com/AkihiroTakamura/items/b93fbe511465f52bffaa)

### 4.4.1 メディアタイプをContent-Typeで指定する必要性
- クライアントの多くは`Content-Type`の値を使ってデータ形式を判断しており、標準的なライブラリにはメディアタイプに厳格なものもあるため、すべてのAPIは適切なメディアタイプをクライアントに返すべき

### 4.4.2 x-で始まるメディアタイプ
- `x-`で始まるメディアタイプは、そのメディアタイプが新しかったり一般的でなくIANA(Internet Assigned Numbers Authority、インターネットに関連する番号を管理する組織)に登録されていないことを意味する。`application/x-yaml`や`image/x-icon`などがある

### 4.4.3 自分でメディアタイプを定義する場合
- 自分で新しいメディアタイプを定義する場合、`x-`で始まるものを定義するべきではない。実は`x-`という形式は1993年発行のRFCで定義された古い形式で、それに変わる`x.`という接頭辞が定義されているが未だに残っているものだから
- 新たにメディアタイプを定義する場合は接頭辞を用いて"Registration tree(登録ツリー)"を区分する

  | ツリー名 | 接頭辞 |
  | ---- | ---- |
  | Standards tree(標準ツリー) | なし |
  | Vendor tree(ベンダツリー) | `vnd` |
  | Personal(Vanity) tree(パーソナルツリー) | prs. |
  | Unregistered tree(未登録ツリー) | x. |

  - ベンダツリーは特定の企業や団体が管理しているデータ形式で、例えばExcelファイルのフォーマットは`application/vnd.ms-excel`となる
  - パーソナルツリーは実験的または公に公開されない製品にのみ、そのデータ形式を利用する場合など
  - 未登録ツリーはローカル環境、プライベート環境で利用するものだが、上2つのツリーでおおよそカバーできるため利用は推奨されていない。
- Web APIを公開する際に新たなサブタイプを定義する場合は、ベンダツリーを使うのが適している。`application/vnd.companyname.awesomeformat`とするなど、`vnd.`に続き団体名などがきて、具体的なフォーマットが続く形式がよい

### 4.4.4 JSONやXMLを用いた新しいデータ形式を定義する場合
- RSSやAtomはXMLの上に定義されているデータ形式で、このように標準化されたデータ形式を使って独自のデータ形式を定義する場合、用いたデータ形式を`+` に続き記述するべきとされている
  | ツリー名 | 接頭辞 |
  | ---- | ---- |
  | application/rss+xml | RSSフィード |
  | application/atom+xml | Atomフィード |

### 4.4.5 メディアタイプとセキュリティ
- メデイァタイプを正しく設定しないとセキュリティ上の問題を引き起こす可能性がある。例えばJSONファイルを`text/html`で配信すると、`XMLHttpRequest`でそのJSONファイルにアクセスしてデータを取得している場合、JSONが`text/html`でも取得ができてしまうが、ブラウザ上ではHTMLとして表示されるため、内部に埋め込まれたJavaScriptが実行される可能性がある

### 4.4.6 リクエストデータとメディアタイプ
- リクエスト時に利用されるメディアタイプは主に`Content-Type`と`Accept`の2つ。前者はPOST時などに用いる。フォームのPOSTでファイル添付など複数のデータを混在させる場合は`multipart/form-data`を指定する
- `Accept`は「どんなメディアタイプを受入可能か」をサーバーに伝えるために利用する。複数のメディアタイプを列挙することができ、各メディアタイプの優先度を設定しサーバー側にデータ形式を委ねることができる(Server Driven COnten Negotiation:サーバー駆動型コンテントネゴシエーション)

  (参考: MDN Web docs - Accept https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Accept

  MDN Web docs - コンテントネゴシエーション　https://developer.mozilla.org/ja/docs/Web/HTTP/Content_negotiation)

## 4.5 同一生成元ポリシーとクロスオリジンリソース共有
- XHTTPRequestでは異なるドメインに対してアクセスを行いレスポンスデータを読み込む事ができない。これは同一生成元ポリシー(Same Origin Policy)によるもの
- 異なる生成元にアクセスするための手法としてクロスオリジンリソース共有(CORS)という仕様が策定されており、特定の生成元からのアクセスのみアクセスの許可が可能

### 4.5.1 CORSの基本的なやりとり
- CORSを行うには、クライアントから`Origin`というリクエストヘッダを送る必要がある。サーバー側では予めアクセスを許可する生成元の一覧を保持しておき、`Origin`で指定された生成元が含まれていなければアクセスを許可せず403エラーを返し、含まれている場合は`Access-Control-Allow-Origin`というレスポンスヘッダに`Origin`と同じ生成元を入れて返すことで許可を示す
- `Access-Control-Allow-Origin`に`*`を指定する事で、アクセスしたリソースがどこから読まれても問題ないことを示す

### 4.5.2 プリフライトリクエスト
- CORSではリクエストが受け入れられるかどうか事前にチェックできるプリフライトリクエストという方法が用意されている
- プリフライトリクエストはOPTIONSメソッドを使って送信する
- (参考: MDN Web docs - OPTIONS https://developer.mozilla.org/ja/docs/Web/HTTP/Methods/OPTIONS)

### 4.5.3 CORSとユーザー認証情報
- CORSではユーザー認証情報(Credential)を送信する際には追加のHTTPレスポンスヘッダを発行する必要がある。例えばクライアントが`Cookie`ヘッダや`Authentication`ヘッダを使ってユーザー認証情報を送ってきた場合、サーバーは`Access-Control-Allow-Origin`ヘッダに`true`をセットして認証情報を認識していることを返す必要がある
- 各ブラウザの`XHTTPRequest`ではCookieなどの認証情報を送る際には`withCredentials`というプロパティをtrueにしなければならない
- (参考: MDN Web docs - XMLHttpRequest.withCredentials https://developer.mozilla.org/ja/docs/Web/API/XMLHttpRequest/withCredentials)

## 4.6 独自のHTTPヘッダを定義する
- 適切なヘッダが存在しないメタデータを送りたい場合、`x-AppName-PixelRatio: 2.0`のようにして独自のHTTPヘッダを定義することができる
- このように`x-`という接頭辞をつけて次にサービスやアプリケーション、組織などの名前をつけるのが一般的。例えばGitHUbでは`X-Github-Request-id`というヘッダでリクエストごとのユニークIDを返している

## 4.7 まとめ
- [Good] HTTPの仕様を最大限利用し、独自仕様の利用を最低限にとどめる
- [Good] 適切なステータスコードを用いる
- [Good] 適切な、なるべく一般的なメディアタイプを返す
- [Good] クライアントが適切なキャッシュを行えるように情報を返す